<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
<!--
.RedText {
	color: #F00;
}
.X {
	color: #F00;
}
-->
</style>
</head>

<body>
<h1>P2P vs. IP Multicast: Simulation Results</h1>
<h3>Stream Characteristics</h3>
<p>Channel bit-rate: 500 kbps (505600 bps with transport overhead, w/o control overhead)</p>
<p>Media: simulated MPEG stream with a GOP having:</p>
<ul>
  <li>I-to-I distance: 9</li>
  <li>I-to-P distance: 3</li>
  <li>GOP sequence: I-B-B-P-B-B-P-B-B</li>
</ul>
<p>Playback rate: 25 frames / second (1 GOP / 360 ms)</p>
<h3>Streaming Mechanisms</h3>
<p>Multicast channels:</p>
<ul>
  <li>Push streaming: 1 multicast group / channel (connectionless, no congestion control)</li>
</ul>
<p>Unicast channels:</p>
<ul>
  <li><em>Single-Tree (S-Tree)</em>: application-level multicast push streaming, 1 tree / channel, connectionless, no congestion control (500 kbps / tree)</li>
  <li><em>Multiple-Tree (M-Tree)</em>: application-level multicast push streaming, connectionless, no congestion control:
    <ul>
      <li><em>M-Tree 3-3</em> layers: 3 trees (layers) / channel,  3 layers required* to start playback (166 kbps / tree)</li>
      <li><em>M-Tree 6-6</em> layers: 6 trees (layers) / channel,  6 layers required to start playback (83 kbps / tree)</li>
      <li><em>M-Tree 9-9</em> layers: 9 trees (layers) / channel,  9 layers required to start playback (55 kbps / tree)</li>
      <li><em>M-Tree 9-3</em> layers: 9 trees (layers) / channel,  3 layers required to start playback (55 kbps / tree)</li>
      <li><em>M-Tree 9-6</em> layers: 9 trees (layers) / channel,  6 layers required to start playback (55 kbps / tree)</li>
    </ul>
  </li>
  <li><em>Mesh (Coolstreaming)</em>: <span class="RedText">TO DO</span></li>
</ul>
<p>*By <em>required</em> layer, we mean a layer that has received a minimum number of frames in it associated playback buffer, such that the layer is no longer in a <em>buffering</em> state (see buffer characteristics below).</p>
<p>Layer frames are <em>not</em> transmitted in parallel, but are interleaved at a GOP level:</p>
<table width="800" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td>Frame no</td>
    <td>01</td>
    <td>02</td>
    <td>03</td>
    <td>04</td>
    <td>05</td>
    <td>06</td>
    <td>07</td>
    <td>08</td>
    <td>09</td>
    <td>10</td>
    <td>11</td>
    <td>12</td>
    <td>13</td>
    <td>14</td>
    <td>15</td>
    <td>16</td>
    <td>17</td>
    <td>18</td>
    <td>19</td>
    <td>20</td>
    <td>21</td>
    <td>22</td>
    <td>23</td>
    <td>24</td>
    <td>25</td>
    <td>26</td>
    <td>27</td>
  </tr>
  <tr>
    <td>Frame type</td>
    <td>I</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
    <td>I</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
    <td>I</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
    <td>P</td>
    <td>B</td>
    <td>B</td>
  </tr>
  <tr>
    <td><em>Layer 1</em></td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><em>Layer 2</em></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><em>Layer 3</em></td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
    <td>X</td>
  </tr>
</table>
<p>&nbsp;</p>
<h3>Bandwidth Characteristics</h3>
<p>Peer have the following uplink bandwidh assigments:</p>
<table width="800" border="0">
  <tr>
    <td>Fraction of peers</td>
    <td>15 %</td>
    <td>20 %</td>
    <td>50 %</td>
    <td>15 %</td>
  </tr>
  <tr>
    <td>Uplink bandwidth</td>
    <td>256 kbps</td>
    <td>640 kbps</td>
    <td>1 Mbps</td>
    <td>1 Mbps</td>
  </tr>
  <tr>
    <td>Downlink bandwidth</td>
    <td>1 Mbps</td>
    <td>1 Mbps</td>
    <td>6 Mbps </td>
    <td>10 Mbps</td>
  </tr>
</table>
<p>All other links in the simulated topology have 1 Gbps. There is no additional traffic.</p>
<h3>Playback Buffer Characteristics</h3>
<p>A playback buffer has two states:</p>
<ul>
  <li>A <em>buffering</em> state, when frames are added and read from the buffer, but the buffer current frame position is not advancing (playback is stopped);</li>
  <li>A <em>play</em> state, when frames are added and read from the buffer, and the buffer current frame position is advancing at the playback rate (playback is started).</li>
</ul>
<p>The playback buffer is described by the following parameters:</p>
<ul>
  <li><em>Buffer size</em> (in frames);</li>
  <li><em>Buffer history size</em>, the maximum number of frames older than the current frame that are kept in the buffer;</li>
  <li><em>Buffering size</em>, the minimum number of frames required in the buffer for the buffer to switch from the <em>buffering</em> to the <em>play</em> state.</li>
</ul>
<p>For <em>full-rate push </em>streaming mechanisms (<em>multicast</em> and <em>S-tree</em>):  </p>
<ul>
  <li>Buffer size: 100 frames</li>
  <li>Buffer history size: 25 frames (almost 3 GOPs)</li>
  <li>Buffering size: 25 frames (almost 3 GOPs)</li>
</ul>
<p>For <em>part-rate push</em> streaming mechanisms (<em>M-tree</em>), the buffer for each tree (layer) is nearly-independent and only with some common elements (such as advancing the playback position):</p>
<ul>
  <li>Buffer size/layer: 35 frames (1/3 of full-rate buffer)</li>
  <li>Buffer history size: 9 frames (1 GOP)</li>
  <li>Buffering size: 9 frames (1 GOP - minimum to ensure that received frames can be decoded)</li>
</ul>
<p>For <em>mesh</em>: <span class="RedText">TO DO</span>
</p>
<h2>Results</h2>
<h3>Network data</h3>
<h4><em>Bandwidth utilization</em></h4>
<p>Comparison between analytical model and simulation</p>
<p><img src="bandwidth.png" width="500" height="350" /></p>
<h4><em>Multicast entries</em></h4>
<p>Comparison between analytical model and simulatio for all entries (PIM-SM and IGMP) and core router entries (PIM-SM).</p>
<p><img src="mcast_entries.png" width="500" height="350" /></p>
<h4><em>Efficiency of the P2P network</em></h4>
<p>Simulation results with the ratio between client upload and download. Illustrates the efficiency of various P2P streaming configurations. The following implementation details apply:</p>
<ul>
  <li>For push-streaming:
    <ul>
      <li>Peers register to a tracker server when they can serve a particular <em>channel</em> (S-tree) or <em>layer</em> (M-tree); the moment of registration is the moment when the buffering state finishes (for the channel or layer) plus an additional guard period of 10 seconds to eliminate short-lived peers;</li>
      <li>Peers deregister for a particular <em>channel</em> or <em>layer</em>, when the associated buffer is no longer in <em>play</em> state;</li>
      <li>Peers measure their uplink bandwidth utilization and accept a new receiver only if they have available <em>k</em>-times the necessary bandwidth where <em>k</em>=1.5 (e.g. for S-tree a peer must have 1.5 x 500 kbps available to accept a new receiver, for M-tree with 3 layers a peer must have 1.5 x 166 kbps available to accept a new receiver);</li>
      <li>Peers use two methods to measure uplink bandwidh utilization:
        <ul>
          <li><em>Static-mode</em>: peers keep track of the number of receiver and allocated bandwidth; this mode does not measure the overhead or 3-rd party traffic;</li>
          <li><em>Dynamic mode</em>: peers use their <em>link meter </em>(a counter implemented by every network link) that give an <em>exponential weighted moving average</em> of the link utilization for each flow direction with a smooth factor of 0.9;</li>
          <li>For the current result, we have used the <em> static mode</em> because it is more accurate when there is no additional traffic. The <em>dynamic mode</em> is similar in over 99% of the sessions, but it responds slightly slower to the actual changes of link utilization.</li>
        </ul>
      </li>
      <li>Sender peers <em>only</em> notify their receivers when leaving the channel.</li>
      <li>Receiver peers use the tracker server to fetch a list of maximum 5 <em>neighbor</em> peers that can be senders. If none of the returned <em>neighbors</em> can serve as senders, the receiver peers will automatically use the streaming server.</li>
      <li>Receiver peers <em>only</em> change their sender peer (for a <em>channel</em> or <em>layer</em>) when there is no frame received for a <em>buffer timeout period </em>of 2 seconds (i.e. if a peer connects to the server it will remain connected for the duration of the session).</li>
      <li>Receiver peer <em>always</em> notify their sender or senders when leaving the channel.</li>
    </ul>
  </li>
  <li>For pull-streaming: <span class="RedText">TO DO</span></li>
</ul>
<p>The multiple-tree streaming exhibits a superior efficiency in using the P2P streaming due to the finer granularity of bandwidth requirements. The disadvantages are:</p>
<ul>
  <li>lower overall quality (due to using peers instead of the server) - see quality results;</li>
  <li>higher delay (due to the buffering delays for interleaved multiple layers) - see delay results;</li>
</ul>
<p><img src="client_upload_fraction.png" width="500" height="350" /></p>
<h3>Streaming data</h3>
<h4><em>Playback quality</em></h4>
<p>The playback quality is the ratio: decoded frames / played frames. Due to this definition, the quality does not measure the session characteristic for the instances when the playback is stopped. These are:</p>
<ul>
  <li>The <em>initial setup</em> period; this is measured through the <em>setup delay</em>;</li>
  <li>The <em>playback pause</em> periods; these are measured through the <em>wait delay</em>.
    <ul>
      <li>For S-tree, a peer enters a <em>pause</em> period when the buffer is no longer in the <em>ready</em> state (no frame received for the <em>buffer timeout period </em>of 2 seconds).</li>
      <li>For M-tree, a peer enters a <em>pause</em> period when the layer buffers in the <em>ready</em> state is less than the minimum required (e.g. 3 layers for M-tree 9-3).</li>
    </ul>
  </li>
</ul>
<p>The stream quality is high (&gt; 0.99) because:</p>
<ul>
  <li>the system manages the	bandwidth constraints by measuring the available at peers;</li>
  <li>when peer bandwidth is not available, the peers use the server;</li>
  <li>there is no 3rd party traffic to generate bottlenecks and losses;</li>
  <li>except for the access network, the core and server links are overprovisoned;</li>
  <li>the only packet losses are due to channel change peer churn.</li>
</ul>
<p>The quality decreases slighly when increasing the number of layers because:</p>
<ul>
  <li>more peers are used (e.g. when g = 0, for M-tree 9/9 almost 60% of the downloaded streaming traffic is uploaded by peers versus S-tree where only 15% is uploaded by peers and the rest by the server - see <em>the efficiency of the P2P network</em>)</li>
</ul>
<p><img src="quality.png" width="600" height="350" /></p>
<p>This figure shows the average quality for each type of streaming.</p>
<p><img src="quality_comparison.png" width="600" height="350" /></p>
<h4><em>Session Delay</em>s</h4>
<p>Each streaming session has the following moments, in order:</p>
<ul>
  <li>session start time: <em>Tstart</em></li>
  <li>time when the first stream packet is received: <em>Trecv</em></li>
  <li>playback start time: <em>Tplay</em></li>
  <li>finish time: <em>Tfinish</em></li>
</ul>
<p>By considering this time instances, we can have the following delays:</p>
<ul>
  <li>setup delay: <em>Dsetup</em> = <em>Tplay</em> - <em>Tstart</em></li>
  <li>bootstrap delay: <em>Dbootstrap</em> = <em>Trecv</em> - <em>Tstart</em></li>
  <li>buffering delay: <em>Dbuffer</em> = <em>Tplay</em> - <em>Trecv</em></li>
</ul>
<p><em>Setup delay</em></p>
<p><img src="delay_setup.png" width="600" height="350" /></p>
<p><em>Bootstrap delay</em></p>
<p><img src="delay_bootstrap.png" width="600" height="350" /></p>
<p><em>Buffering delay</em></p>
<p><img src="delay_buffering.png" width="600" height="350" /></p>
<p><em>Average values for delay components for each streaming type</em></p>
<p><img src="delay_components.png" width="600" height="350" /></p>
<h4><em>Synchronization delay</em></h4>
<p>In addition to the session delay there exists a <em>sync delay</em>, which is the time difference between the moment when a frame is played at the receiver and the moment the frame was transmitted at the media server.</p>
<p>This delay measures the <em>network</em> <em>(transmission, queing, forwarding, etc) delay </em>that streaming packets take from the server to each final destination <em>plus</em> the <em>buffering delay </em>at the final destination <em>minus </em>a small amount*.</p>
<p><img src="delay_sync.png" width="600" height="350" /></p>
<p>*When playback is starting at the moment the buffer (or buffers for multiple layers) goes from<em> buffering</em> to <em>play</em> state, the client will not start playback with the first frame in the buffer, but rather, it will look for the first frame that can be decoded, usually an I frame skipping several frames. Depending on the position of the first I frame with respect to the beginning of the buffer the actual sync delay will be smaller.</p>
<p><em>Example:</em> In the figure above, the sync delay for S-tree scenario and all channels multicast (<em>g</em> = 100), the sync delay is 830 ms. This value comes from:</p>
<ul>
  <li>A <em>buffering</em> delay of 25 frames: <em>Tbuffering</em> = 25 x 40 ms = 1000 ms.</li>
  <li>Minus the delay due to the jump to the first I frame. If we assume the first I frame uniformly distributed over the first 9 frames (1 GOP), then the average distance to the first I frame is 4.5 x 40 ms = 180 ms.</li>
</ul>
<p>This gives us a sync delay of 820 ms. The rest of 10 ms is the network delay for the packet to each the client starting from the server.</p>
<h1>Flow Congestion Control</h1>
<h2>Scenario 1</h2>
<p><img src="fig1-1.png" width="560" height="420" /><img src="fig1-2.png" width="560" height="420" /><img src="fig1-3.png" width="560" height="420" /><img src="fig1-4.png" width="560" height="420" /></p>
<h2>Scenario 2</h2>
<p><img src="fig2-1.png" width="560" height="420" /><img src="fig2-2.png" width="560" height="420" /><img src="fig2-3.png" width="560" height="420" /><img src="fig2-4.png" width="560" height="420" /></p>
<h2>Scenario 3</h2>
<p><img src="fig3-1.png" width="560" height="420" /><img src="fig3-2.png" width="560" height="420" /><img src="fig3-3.png" width="560" height="420" /><img src="fig3-4.png" width="560" height="420" /></p>
<h2>Scenario 4</h2>
<h2><img src="fig4-1.png" width="560" height="420" /><img src="fig4-2.png" width="560" height="420" /><img src="fig4-3.png" width="560" height="420" /><img src="fig4-4.png" width="560" height="420" /></h2>
</body>
</html>
